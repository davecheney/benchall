package jujusvg

import (
	"bytes"
	"encoding/xml"
	"image"
	"io"

	"github.com/ajstarks/svgo"
	jc "github.com/juju/testing/checkers"
	gc "gopkg.in/check.v1"

	"gopkg.in/juju/jujusvg.v1/assets"
)

type CanvasSuite struct{}

var _ = gc.Suite(&CanvasSuite{})

func (s *CanvasSuite) TestServiceRender(c *gc.C) {
	// Ensure that the Service's definition and usage methods output the
	// proper SVG elements.
	var tests = []struct {
		about    string
		service  service
		expected string
	}{
		{
			about: "Service without iconSrc, no def created",
			service: service{
				name: "foo",
				point: image.Point{
					X: 0,
					Y: 0,
				},
				iconUrl: "foo",
			},
			expected: `<use x="0" y="0" xlink:href="#serviceBlock" id="foo" />
<image x="46" y="46" width="96" height="96" xlink:href="foo" />
<g style="font-size:18px;fill:#505050;text-anchor:middle">
<text x="94" y="31" >foo</text>
</g>
`,
		},
		{
			about: "Service with iconSrc",
			service: service{
				name:      "bar",
				charmPath: "bar",
				point: image.Point{
					X: 0,
					Y: 0,
				},
				iconSrc: []byte("<svg>bar</svg>"),
			},
			expected: `<svg:svg xmlns:svg="http://www.w3.org/2000/svg" id="icon-1">bar</svg:svg><use x="0" y="0" xlink:href="#serviceBlock" id="bar" />
<use x="46" y="46" xlink:href="#icon-1" width="96" height="96" />
<g style="font-size:18px;fill:#505050;text-anchor:middle">
<text x="94" y="31" >bar</text>
</g>
`,
		},
		{
			about: "Service with already def'd icon",
			service: service{
				name:      "baz",
				charmPath: "bar",
				point: image.Point{
					X: 0,
					Y: 0,
				},
				iconSrc: []byte("<svg>bar</svg>"),
			},
			expected: `<use x="0" y="0" xlink:href="#serviceBlock" id="baz" />
<use x="46" y="46" xlink:href="#icon-1" width="96" height="96" />
<g style="font-size:18px;fill:#505050;text-anchor:middle">
<text x="94" y="31" >baz</text>
</g>
`,
		},
	}
	// Maintain our list of rendered icons outside the loop.
	iconsRendered := make(map[string]bool)
	iconIds := make(map[string]string)
	for _, test := range tests {
		var buf bytes.Buffer
		svg := svg.New(&buf)
		test.service.definition(svg, iconsRendered, iconIds)
		test.service.usage(svg, iconIds)
		c.Assert(buf.String(), gc.Equals, test.expected)
	}
}

func (s *CanvasSuite) TestRelationRender(c *gc.C) {
	// Ensure that the Relation's definition and usage methods output the
	// proper SVG elements.
	var buf bytes.Buffer
	svg := svg.New(&buf)
	relation := serviceRelation{
		serviceA: &service{
			point: image.Point{
				X: 0,
				Y: 0,
			},
		},
		serviceB: &service{
			point: image.Point{
				X: 100,
				Y: 100,
			},
		},
	}
	relation.definition(svg)
	relation.usage(svg)
	c.Assert(buf.String(), gc.Equals,
		`<line x1="94" y1="189" x2="100" y2="194" stroke="#38B44A" stroke-width="2px" stroke-dasharray="-6.09, 20" />
<use x="87" y="181" xlink:href="#healthCircle" />
`)
}

func (s *CanvasSuite) TestLayout(c *gc.C) {
	// Ensure that the SVG is sized exactly around the positioned services.
	canvas := Canvas{}
	canvas.addService(&service{
		point: image.Point{
			X: 0,
			Y: 0,
		},
	})
	canvas.addService(&service{
		point: image.Point{
			X: 100,
			Y: 100,
		},
	})
	width, height := canvas.layout()
	c.Assert(width, gc.Equals, 289)
	c.Assert(height, gc.Equals, 289)
	canvas.addService(&service{
		point: image.Point{
			X: -100,
			Y: -100,
		},
	})
	canvas.addService(&service{
		point: image.Point{
			X: -100,
			Y: 100,
		},
	})
	canvas.addService(&service{
		point: image.Point{
			X: 200,
			Y: -100,
		},
	})
	width, height = canvas.layout()
	c.Assert(width, gc.Equals, 489)
	c.Assert(height, gc.Equals, 389)
}

func (s *CanvasSuite) TestMarshal(c *gc.C) {
	// Ensure that the internal representation of the canvas can be marshalled
	// to SVG.
	var buf bytes.Buffer
	canvas := Canvas{}
	serviceA := &service{
		name:      "service-a",
		charmPath: "trusty/svc-a",
		point: image.Point{
			X: 0,
			Y: 0,
		},
		iconSrc: []byte(`
			<svg xmlns="http://www.w3.org/2000/svg" class="blah">
				<circle cx="20" cy="20" r="20" style="fill:#000" />
			</svg>`),
	}
	serviceB := &service{
		name: "service-b",
		point: image.Point{
			X: 100,
			Y: 100,
		},
	}
	canvas.addService(serviceA)
	canvas.addService(serviceB)
	canvas.addRelation(&serviceRelation{
		serviceA: serviceA,
		serviceB: serviceB,
	})
	canvas.Marshal(&buf)
	c.Logf("%s", buf)
	assertXMLEqual(c, buf.Bytes(), []byte(`
<?xml version="1.0"?>
<!-- Generated by SVGo -->
<svg width="289" height="289"
     style="font-family:Ubuntu, sans-serif;" viewBox="0 0 289 289"
     xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink">
<defs>
<g id="serviceBlock" transform="scale(0.8)" >`+assets.ServiceModule+`
</g>
<g id="healthCircle">
<circle cx="10" cy="10" r="10" style="stroke:#38B44A;fill:none;stroke-width:2px"/>
<circle cx="10" cy="10" r="5" style="fill:#38B44A"/>
</g>
<svg xmlns="http://www.w3.org/2000/svg" class="blah" id="icon-1">
<circle cx="20" cy="20" r="20" style="fill:#000"></circle>
</svg>
</defs>
<g id="relations">
<line x1="94" y1="189" x2="100" y2="194" stroke="#38B44A" stroke-width="2px" stroke-dasharray="-6.09, 20" />
<use x="87" y="181" xlink:href="#healthCircle" />
</g>
<g id="services">
<use x="0" y="0" xlink:href="#serviceBlock" id="service-a" />
<use x="46" y="46" xlink:href="#icon-1" width="96" height="96" />
<g style="font-size:18px;fill:#505050;text-anchor:middle">
<text x="94" y="31" >service-a</text>
</g>
<use x="100" y="100" xlink:href="#serviceBlock" id="service-b" />
<image x="146" y="146" width="96" height="96" xlink:href="" />
<g style="font-size:18px;fill:#505050;text-anchor:middle">
<text x="194" y="131" >service-b</text>
</g>
</g>
</svg>
`))
}

func assertXMLEqual(c *gc.C, obtained, expected []byte) {
	toksObtained := xmlTokens(c, obtained)
	toksExpected := xmlTokens(c, expected)
	c.Assert(toksObtained, jc.DeepEquals, toksExpected)
}

func xmlTokens(c *gc.C, data []byte) []xml.Token {
	dec := xml.NewDecoder(bytes.NewReader(data))
	var toks []xml.Token
	for {
		tok, err := dec.Token()
		if err == io.EOF {
			return toks
		}
		c.Assert(err, gc.IsNil)

		if cdata, ok := tok.(xml.CharData); ok {
			// It's char data - trim all white space and ignore it
			// if it's all blank.
			cdata = bytes.TrimSpace(cdata)
			if len(cdata) == 0 {
				continue
			}
			tok = cdata
		}
		toks = append(toks, xml.CopyToken(tok))
	}
}
